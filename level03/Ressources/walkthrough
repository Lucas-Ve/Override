# ğŸ“˜ Override â€“ Level03

## ğŸ“ Description

Ce niveau du projet **Override** repose non pas sur un buffer overflow, mais sur une **erreur cryptographique fondamentale** : une chaÃ®ne est chiffrÃ©e via un simple XOR Ã  clÃ© unique, et le programme utilise un calcul dÃ©terministe basÃ© sur le mot de passe entrÃ© pour dÃ©river cette clÃ©.
Comme la mÃ©thode de chiffrement est rÃ©versible, il est trivial de retrouver la clÃ© XOR et donc de dÃ©duire le **mot de passe exact** Ã  fournir.

Lâ€™objectif est de comprendre la logique du programme, dâ€™analyser la fonction `decrypt()`, de retrouver la clÃ© XOR et dâ€™en dÃ©duire le mot de passe permettant de dÃ©clencher un shell.

---

## ğŸ” Analyse du binaire

### Code pertinent (rÃ©sumÃ©)

```c
void test(int param_1, int param_2)
{
    EVP_PKEY_CTX *pEVar1;

    pEVar1 = (EVP_PKEY_CTX *)(param_2 - param_1);
    decrypt(pEVar1, ...);
}

int decrypt(EVP_PKEY_CTX *ctx, uchar *out, ...)
{
    byte local_21[17] = {
        0x51,0x7d,0x7c,0x75,0x60,0x73,0x66,0x67,
        0x7e,0x73,0x66,0x7b,0x7d,0x7c,0x61,0x33,0x00
    };

    for (i = 0; i < 16; i++)
        local_21[i] ^= (byte)ctx;

    if (!strcmp((char*)local_21, "Congratulations!"))
        system("/bin/sh");
    else
        puts("Invalid Password");
}
```

### Ce quâ€™il faut retenir

* `local_21` contient une **chaÃ®ne chiffrÃ©e fixe**.

* Chaque caractÃ¨re est dÃ©chiffrÃ© via :

  ```
  dÃ©chiffrÃ©[i] = chiffrÃ©[i] XOR (byte)ctx
  ```

* Le rÃ©sultat est comparÃ© Ã  `"Congratulations!"`.

* Si Ã§a matche â†’ `system("/bin/sh")`.

---

## ğŸ§© Comprendre la dÃ©rivation de la clÃ©

La fonction `test()` calcule :

```c
ctx = param_2 - param_1;
```

Et dans le vrai binaire :

```
param_2 = 0x1337d00d
param_1 = password_input
```

Donc :

```
ctx = 0x1337d00d - password
```

Puis seul lâ€™octet bas est utilisÃ© :

```
(byte)ctx
```

---

## ğŸ” Trouver la clÃ© XOR

Nous savons que :

```
cipher[0] XOR key = plaintext[0]
```

Avec :

* `cipher[0] = 0x51 ('Q')`
* `plaintext[0] = 'C' = 0x43`

Donc :

```
key = 0x51 XOR 0x43 = 0x12  (18 dÃ©cimal)
```

âœ” La clÃ© XOR est **0x12**.

Nous voulons donc que :

```
(byte)ctx = 0x12
```

Or :

```
ctx = 0x1337d00d - password
```

Donc :

```
0x1337d00d - password = 0x12
```

---

## ğŸ§® Calcul du mot de passe

```
password = 0x1337d00d - 0x12
password = 0x1337cffb
```

Converti en dÃ©cimal :

```
322424827
```

ğŸ‘‰ **Câ€™est le mot de passe correct.**

---

## ğŸš€ Exploitation

ExÃ©cution du programme :

```
level03@OverRide:~$ ./level03
***********************************
*            level03             **
***********************************
Password:322424827
$ whoami
level04
$ cat /home/users/level04/.pass
kgv3tkEb9h2mLkRsPkXRfc2mHbjMxQzvb2FrgKkf
```

âœ” Shell obtenu
âœ” Mot de passe du niveau 04 rÃ©cupÃ©rÃ©

---

## ğŸ“Œ RÃ©sumÃ©

| Ã‰lÃ©ment                 | Valeur                           |
| ----------------------- | -------------------------------- |
| Type de vulnÃ©rabilitÃ©   | Chiffrement XOR rÃ©versible       |
| ChaÃ®ne chiffrÃ©e         | 17 octets en dur dans le binaire |
| ChaÃ®ne attendue         | `"Congratulations!"`             |
| ClÃ© XOR trouvÃ©e         | `0x12`                           |
| Relation clÃ© â‡¢ password | `ctx = 0x1337d00d - password`    |
| Mot de passe final      | **322424827**                   |
| RÃ©sultat                | Shell â†’ *level04*                |

---

## ğŸ§  Points pÃ©dagogiques

* Le XOR Ã  clÃ© unique est **rÃ©versible** dÃ¨s quâ€™on connaÃ®t un seul octet de texte en clair.
* Le cast `(byte)ctx` rÃ©duit la sÃ©curitÃ© Ã  **1 seul octet**, rendant lâ€™opÃ©ration triviale.
* Le challenge illustre parfaitement pourquoi on ne doit **jamais coder soi-mÃªme de la crypto**.
