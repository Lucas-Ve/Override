# üìò Override ‚Äì Level06

## üìù Description

Ce niveau introduit un m√©canisme d‚Äôauthentification bas√© sur un **serial g√©n√©r√© dynamiquement √† partir du login**.  
L‚Äôobjectif est d‚Äôanalyser la fonction `auth()` en reverse engineering afin de **recalculer exactement le serial attendu**, permettant d‚Äôobtenir un shell en tant que *level07*.

Le challenge est compliqu√© par un m√©canisme anti-debug (`ptrace`) emp√™chant l‚Äôutilisation directe de GDB.

---

## üîç Analyse du binaire

### Code principal

```c
printf("-> Enter Login: ");
fgets(local_34, 0x20, stdin);

printf("-> Enter Serial: ");
scanf("%u", &serial);

if (auth(local_34, serial) == 0) {
    system("/bin/sh");
}
````

Le programme lit :

1. un **login** (max 32 chars)
2. un **serial** (unsigned int)

Puis valide le serial via `auth()`.

---

## üîí Fonction `auth()`

Voici ce que la fonction fait :

### 1Ô∏è‚É£ Nettoyage du login

```c
param_1[strcspn(param_1, "\n")] = '\0';
if (strlen(param_1) < 6) return 1;
```

‚û°Ô∏è Login **‚â• 6 caract√®res** obligatoire.

---

### 2Ô∏è‚É£ Anti-debug (ptrace)

```c
if (ptrace(PTRACE_TRACEME) == -1) {
    // TAMPERING DETECTED
    return 1;
}
```

‚û°Ô∏è Impossible d‚Äôex√©cuter normalement sous GDB
(MAIS on va bypasser √ßa üí°).

---

### 3Ô∏è‚É£ Initialisation du seed

```c
seed = (login[3] ^ 0x1337) + 0x5eeded;
```

‚úî Tr√®s important : le hash d√©pend de la **4·µâ lettre du login**.

---

### 4Ô∏è‚É£ Algorithme de hash

Pour chaque caract√®re du login :

```c
if (login[i] < ' ') return 1;   // invalid chars

seed += ((login[i] ^ seed) % 1337);
```

‚û°Ô∏è Le seed final d√©pend :

* de **chaque caract√®re**
* de la **longueur**
* de l‚Äôordre
* de la valeur ASCII

---

### 5Ô∏è‚É£ V√©rification finale

```c
return (serial == seed) ? 0 : 1;
```

‚û°Ô∏è Si `serial == seed` ‚Üí shell.

---

## üéØ Objectif

Pour un login donn√©, il suffit de **recalculer le m√™me seed** en reproduisant la fonction `auth()`.

---

## üß† Reverse engineering + Bypass ptrace

Pour observer le `seed` dans GDB, il faut bypasser le `ptrace(PTRACE_TRACEME)`.

### üõ†Ô∏è M√©thode efficace

1. Break juste apr√®s l‚Äôappel √† `ptrace`

   ```gdb
   b *0x080487ba
   ```
2. Break avant la comparaison finale

   ```gdb
   b *0x08048866
   ```
3. Run

   ```gdb
   r
   ```
4. Quand GDB s‚Äôarr√™te au ptrace

   ```gdb
   set $eax=1     # Simule un ptrace r√©ussi
   c
   ```
5. √Ä la fin de la fonction `auth()`, afficher `seed`

   ```gdb
   p/x *(int*)($ebp - 0x10)
   ```

---

## üß™ Exemple avec le login : `lveloso`

### Suivi dans GDB :

```
Breakpoint 1: ptrace bypass
set $eax=1
continue
```

Puis :

```
Breakpoint 2: end of auth()
print *(int*)($ebp - 0x10)
$1 = 6233762
```

‚û°Ô∏è Le serial attendu est **6233762**.

---

## üöÄ Exploitation

```bash
level06@OverRide:~$ ./level06 
-> Enter Login: lveloso
-> Enter Serial: 6233762
Authenticated!
$ whoami
level07
$ cat /home/users/level07/.pass
GbcPDRgsFK77LNnnuh7QyFYA2942Gp8yKj9KrWD8
```

---

## ‚úî R√©sum√©

| √âl√©ment              | Valeur                                     |
| -------------------- | ------------------------------------------ |
| Vuln√©rabilit√©        | Fonction de hash reversible                |
| Protection g√™nante   | `ptrace(PTRACE_TRACEME)`                   |
| Bypass               | `set $eax = 0` apr√®s le call ptrace        |
| seed = serial        | d√©pend uniquement du login                 |
| Acc√®s obtenu         | Shell level07                              |
| Mot de passe level07 | `GbcPDRgsFK77LNnnuh7QyFYA2942Gp8yKj9KrWD8` |
